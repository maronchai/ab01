<!DOCTYPE html>
<html>
<head>
<title>きらきらブロック崩し</title>
<style>
  body {
    background: #f0f8ff; /* 全体の背景色を淡い水色に */
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    font-family: 'Comic Sans MS', cursive, sans-serif; /* 可愛らしいフォント */
    color: #333;
  }
  canvas {
    background: linear-gradient(135deg, #a8dadc, #457b9d); /* 初期背景はグラデーション */
    display: block;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
    border-radius: 15px; /* 角を丸く */
    transition: background 1s ease-in-out; /* 背景色変更を滑らかに */
  }
</style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>
// JavaScript: ゲームロジック

// 1. セットアップ
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

// レベル管理
let level = 1;
const maxLevel = 5;

// レベルごとのテーマカラー（背景、ボール、パドル、ブロック）
const levelThemes = {
  1: {
    background: 'linear-gradient(135deg, #a8dadc, #457b9d)', // 淡い水色グラデ
    ball: '#e63946', // 赤
    paddle: '#1d3557', // 濃い青
    brick: '#f1faee' // 薄いクリーム
  },
  2: {
    background: 'linear-gradient(135deg, #fce4ec, #f8bbd0)', // 薄いピンクグラデ
    ball: '#c2185b', // 濃いピンク
    paddle: '#880e4f', // ボルドー
    brick: '#ffebee' // 超薄いピンク
  },
  3: {
    background: 'linear-gradient(135deg, #e0f7fa, #80deea)', // 薄いミントグラデ
    ball: '#00bcd4', // シアン
    paddle: '#006064', // 濃いシアン
    brick: '#e0f2f7' // 薄い水色
  },
  4: {
    background: 'linear-gradient(135deg, #fff9c4, #fff176)', // 薄い黄グラデ
    ball: '#ffeb3b', // 黄色
    paddle: '#f57f17', // オレンジ
    brick: '#fffde7' // 超薄い黄
  },
  5: {
    background: 'linear-gradient(135deg, #e8eaf6, #7986cb)', // 薄い紫グラデ
    ball: '#673ab7', // 紫
    paddle: '#311b92', // 濃い紫
    brick: '#e8eaf6' // 薄い薄い紫
  }
};


// ボール
let x;
let y;
let dx; 
let dy; 
const ballRadius = 10;
const BASE_SPEED = 2.5; // レベル1の基本速度（少し速めに）

// パドル（台）
const paddleHeight = 10;
const paddleWidth = 75;
let paddleX;
let rightPressed = false;
let leftPressed = false;

// ブロック
const brickRowCount = 3;
const brickColumnCount = 5;
const brickWidth = 75;
const brickHeight = 20;
const brickPadding = 10;
const brickOffsetTop = 30;
const brickOffsetLeft = 30;
const bricks = []; // 2次元配列として使用

// スコア
let score = 0;

// ----------------------------------------------
// 図形描画ヘルパー関数 (星形)
// ----------------------------------------------
function drawStar(cx, cy, spikes, outerRadius, innerRadius, color) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
}


// ----------------------------------------------
// 初期化・リセット関数
// ----------------------------------------------

// ブロックの配置を初期化
function initializeBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
      bricks[c][r] = { x: 0, y: 0, status: 1 };
    }
  }
}

// ボールとパドルの位置、スピードをリセット（レベルアップ時にも使用）
function resetBallAndPaddle() {
  x = canvas.width / 2;
  y = canvas.height - 30;
  
  // レベルとランダム性に応じたスピードを計算
  // レベルが上がるごとに速くなる + サイトを開くたびに初期速度が少しランダムに
  const baseSpeed = BASE_SPEED + (Math.random() * 1 - 0.5); // +-0.5の範囲でランダムな初期速度
  const speedMultiplier = 1 + (level - 1) * 0.5; 
  dx = baseSpeed * speedMultiplier * (Math.random() < 0.5 ? 1 : -1); // 初期X方向もランダム
  dy = -baseSpeed * speedMultiplier; // 初期Y方向は上向き

  // スピードが極端に遅くならないように最小値を設定
  if (Math.abs(dx) < 1) dx = dx > 0 ? 1 : -1;
  if (Math.abs(dy) < 1) dy = dy > 0 ? 1 : -1;
  
  paddleX = (canvas.width - paddleWidth) / 2;
}

// 初回ゲーム開始時の設定
function initGame() {
    applyTheme(level); // 初期テーマを適用
    initializeBricks(); // ブロック生成
    resetBallAndPaddle(); // ボールとパドルを初期位置に
}

// テーマを適用する関数
function applyTheme(currentLevel) {
  const theme = levelThemes[currentLevel];
  // グラデーションの場合、CSSプロパティとして設定
  canvas.style.background = theme.background;
}


// ----------------------------------------------
// イベントリスナー（キー操作）
// ----------------------------------------------
document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);

function keyDownHandler(e) {
  if (e.key === "Right" || e.key === "ArrowRight") {
    rightPressed = true;
  } else if (e.key === "Left" || e.key === "ArrowLeft") {
    leftPressed = true;
  }
}

function keyUpHandler(e) {
  if (e.key === "Right" || e.key === "ArrowRight") {
    rightPressed = false;
  } else if (e.key === "Left" || e.key === "ArrowLeft") {
    leftPressed = false;
  }
}

// ----------------------------------------------
// 描画関数
// ----------------------------------------------

function drawBall() {
  // ボールを星形に描画！
  drawStar(x, y, 5, ballRadius, ballRadius / 2, levelThemes[level].ball);
}

function drawPaddle() {
  ctx.beginPath();
  ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
  ctx.fillStyle = levelThemes[level].paddle;
  ctx.fill();
  ctx.closePath();
}

function drawBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
        const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;
        ctx.beginPath();
        ctx.rect(brickX, brickY, brickWidth, brickHeight);
        ctx.fillStyle = levelThemes[level].brick;
        ctx.fill();
        ctx.closePath();
      }
    }
  }
}

function drawScore() {
  ctx.font = "bold 20px 'Comic Sans MS', cursive"; /* 可愛らしいフォント */
  ctx.fillStyle = "#ffffff"; /* 白文字で見やすく */
  ctx.fillText("Score: " + score, 8, 25);
  ctx.fillText("Level: " + level, canvas.width - 100, 25); 
}

// ----------------------------------------------
// ロジック関数
// ----------------------------------------------

// ステージクリア時の処理
function levelUp() {
    if (level < maxLevel) {
        level++;
        alert(`きらきら！ステージクリア！レベル ${level} へアップ！`);

        // 1. 画面の色を変更
        applyTheme(level);

        // 2. ブロックを再生成
        initializeBricks();

        // 3. ボールとパドルの位置とスピードをリセット
        resetBallAndPaddle();

    } else {
        // 最終レベルをクリア
        alert("全ステージきらきらクリア！おめでとうございます！");
        document.location.reload(); 
    }
}

// 衝突判定
function collisionDetection() {
  let remainingBricks = 0;
  
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      const b = bricks[c][r];
      if (b.status === 1) {
        remainingBricks++; 

        if (
          x > b.x && x < b.x + brickWidth &&
          y > b.y && y < b.y + brickHeight
        ) {
          dy = -dy; 
          b.status = 0; 
          score++; 
          remainingBricks--; 
        }
      }
    }
  }
  
  if (remainingBricks === 0) {
    levelUp();
  }
}


// ----------------------------------------------
// メインの描画ループ
// ----------------------------------------------
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height); // 背景はCSSで管理するためclearRectは要素だけ

  drawBricks();
  drawBall();
  drawPaddle();
  drawScore();
  collisionDetection();

  // ボールの動きと壁の反射
  if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
    dx = -dx; 
  }
  if (y + dy < ballRadius) {
    dy = -dy; 
  } else if (y + dy > canvas.height - ballRadius) {
    if (x > paddleX && x < paddleX + paddleWidth) {
      // パドルのどの位置に当たったかで反射角度を少し変える
      // ボールがパドルの端に当たったらより大きく角度がつく
      const hitPoint = (x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
      dx = hitPoint * Math.abs(dx); // X方向の速度を調整
      dy = -dy; 
    } else {
      alert("ざんねん... ゲームオーバー！もう一回やってみよう！");
      document.location.reload(); 
    }
  }

  // パドルの動き
  if (rightPressed && paddleX < canvas.width - paddleWidth) {
    paddleX += 7;
  } else if (leftPressed && paddleX > 0) {
    paddleX -= 7;
  }

  // ボールの位置を更新
  x += dx;
  y += dy;

  requestAnimationFrame(draw);
}

// ゲーム開始
initGame();
draw();
</script>

</body>
</html>
